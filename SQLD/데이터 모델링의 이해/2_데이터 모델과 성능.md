### 데이터 모델링 순서

1. 정규화를 정확하게 수행
2. 용량산정 수행
3. 트랜잭션의 유형 파악
4. 반정규화 수행
5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정

# 1️⃣ 정규화와 성능

### 정규화 정의

- 데이터를 분해하는 과정
- 정규화된 모델은 테이블 분해 가능
- 데이터 중복을 제거 → 데이터 모델의 독립성을 확보 + 조회성능 향상
- 정규화 수행하지 않을 시 이상현상 발생

### 정규화 절차

- `제1정규화`
    - 기본키를 설정
    - 속성의 원자성을 확보
    - 중복 속성에 대한 분리
- `제2정규화`
    - 부분 함수 종속성 제거
    - 기본키가 2개 이상의 칼럼으로 이뤄진 경우 분해
- `제3정규화`
    - 이행 함수 종속성 제거
    - 기본키를 제외한 칼럼간에 종속성이 발생되는 경우 제거
- BNCF
    - 복수의 후보키 + 후보키들이 복합 속성 + 서로 중첩
    - 기본키가 후보키를 함수적으로 종속
    - 후보키가 기본키를 함수적으로 종속하는 경우 분해
- `제4정규화`
    - 여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해
- `제5정규화`
    - 조인에 의해 종속성이 발생되는 경우 제거

- ⚠️ 1차 정규화의 대상 → 중복속성이 있는 엔티티, 1:M 관계로 재생성 가능
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98a871ae-6821-4b6a-8f98-d32ba7b2ddfa/Untitled.png)
    
- ⚠️ 2차 정규화의 대상 → 부분함수의 종속성 규칙
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/57e55e0b-ee4c-431b-b6c5-52890e429054/Untitled.png)
    

### 정규화 문제점

- SELECT 시 조인을 유발해 CPU와 메모리 많이 사용

# 2️⃣ 반정규화와 성능

### 반정규화 정의

- 데이터 중복을 허용하고 조인을 줄여 성능향상

⚠️ 반정규화 고려하는 판단요소 → 반정규화 정보에 대한 재현의 적시성으로 판단. 예를 들어, 빌링의 잔액은 다수 테이블에 대한 다량의 조인이 불가피하므로 데이터 제공의 적시성 확보를 위한 필수 반정규화 대상 정보

### 수행하는 경우

- 정규화에 의해 수행 속도가 느려지는 경우
- 다량의 범위를 자주 처리해야 하는 경우
- 특정 범위의 데이터만 자주 처리하는 경우
- 요약/집계 정보가 자주 요구되는 경우

### 반정규화 기법

- 칼럼의 반정규화 기법
    - 중복 칼럼 추가
    - 파생 칼럼 추가
    - 이력 테이블 칼럼 추가
    - PK에 의한 칼럼 추가
    - 응용시스템 오작동을 칼럼 추가
    
- 테이블의 반정규화 기법
    - 테이블 추가
        - 중복테이블 추가
        - 통계테이블 추가
        - 이력테이블 추가
        - 부분테이블 추가
    - 테이블 분할
        - 테이블 수직분할
        - 테이블 수평분할
    - 테이블 병합
        - 1:1관계 테이블 병합
        - 1:M관계 테이블 병합
        - 슈퍼/서브타입 테이블 병합

⚠️ **FK에 대한 속성 추가는 데이터 모델링에서 관계를 연결할 때 나타나는 자연스러운 현상[반정규화 기법 X]**

### 주요 반정규화 기법

| 중복 칼럼 추가 | 조인 감소를 위해 여러 테이블에 동일한 칼럼을 추가 |
| --- | --- |
| 파생 칼럼 추가[계산된 칼럼 추가] | 조회 성능을 우수하게 하기 위해 미리 계산된 칼럼을 추가    → 배치 프로그램으로 미리 계산한 결과를 특정 칼럼에 추가 |
| 이력테이블 칼럼 추가 | 최신값을 처리하는 이력의 특성을 고려해 기능성 칼럼 추가 |
| 부분테이블 추가 | 하나의 테이블의 전체 칼럼 중 자주 사용하는 집중화된 칼럼들을 별도의 테이블에 추가  → 디스크 I/O를 줄일 수 있음 |
| 테이블 수직 분할 | 하나의 테이블을 두 개 이상의 테이블로 분할칼럼을 분할해 새로운 테이블을 만듦 |
| 테이블 수평 분할 | 하나의 테이블에 있는 값을 기준으로 테이블을 분할 동일한 칼럼에 다른 값을 가진 새로운 테이블을 만듦 [특정 값의 범위에 따라 분할] |

### 반정규화 절차

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d459c386-08ff-4058-bc82-1931ff1418c8/Untitled.png)

### 반정규화의 대상에 대해 다른 방법으로 처리

- 지나치게 많은 조인
    - 뷰 사용
- 대량의 데이터 처리나 부분처리
    - 클러스터링 or 인덱스 조정
- 대량의 데이터
    - PK 성격에 따라 부분적인 테이블로 분리 (=파티셔닝)
- 전반적 향상
    - 응용애플리케이션에서 로직을 구사하는 방법 변경

# 3️⃣ 대용량 데이터에 따른 성능

## 용량산정

### 대량의 데이터로 인한 문제

- 로우체이닝
    - 로우 길이가 너무 길어 하나의 데이터 블록에 저장되지 못하는 경우
    - 두 개 이상의 데이터 블록에 걸쳐 하나의 로우가 저장
- 로우 마이그레이션
    - 늘어난 저장곤간으로 인해 수정된 데이터를 해당 데이터 블록에 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

## 파티셔닝

### 파티션 정의

- 하나의 테이블에 파티션을 사용해 테이블을 분할하는 기법
- 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 데이터 파일에 분산되어 저장

### 파티셔닝 종류

- `Range Partition`
    - 데이터 값의 범위를 기준으로
- `List Partition`
    - 특정한 값을 지정하여
- `Hash Partition`
    - 해시 함수를 적용해
    - DBMS 에서 스스로 분할 및 관리
- `Composite Partition`
    - 범위 + 해시 를 복합적으로 사용

### 파티션 인덱스

- `Global Index`
    - 여러 개의 파티션 - 하나의 인덱스 사용
- `Local Index`
    - 해당 파티션 별로 - 각자의 인덱스 사용
- `Prefixed Index`
    - 파티션 키 = 인덱스 키
- `Non Prefixed Index`
    - 파티션 키 ≠ 인덱스 키

# 4️⃣ DB 구조와 성능

## 슈퍼타입/서브타입

논리적인 데이터 모델에서 이용되는 형태 ⇒ `Extended ER 모델`이라고도 함

### 슈퍼/서브 타입 데이터 모델의 변환기술

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b8e0165-f0ef-4f8c-a422-feb647161a4f/Untitled.png)

- `OneToOne Type`
    - **Super Type과 Sub Type을 개별 테이블로 도출**
    - 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
    - 슈퍼타입이 각 서브탕비에 대해 기준역할을 하는 형식으로 사용할때 이러한 유형의 트랜잭션 발생
    - 테이블 수가 많아서 조인이 많이 발생하고 관리가 어려움
- `Plus Type`
    - **Super Type과 Sub Type 테이블로 도출**
    - 슈퍼+서브 타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼+서브 타입 테이블로 구성
    - 조인이 발생하고 관리가 어려움
- `Single Type`
    - **Super Type과 Sub Type을 하나의 테이블로 도출**
    - 테이블들을 하나로 묶었을 때 각각의 속성별로 제약사항(NULL/NOT NULL, 기본값, 체크값)을 정확하게 지정하지 못할지라도 대용량이고 성능향상이 필요하다면 하나의 테이블로 묶어서 만들어 줌.
    - **조인 성능이 좋고** 관리가 편리하지만 입출력 성능이 나쁨

- 슈퍼/서브타입에 대한 변환을 잘못하여 성능이 저하되는 경우
    - `트랜잭션` 항상 전체를 일괄 처리 + `테이블` 서브타입별 개별 유지되어 변환
        
        ⇒ Union 연산에 의해 성능이 저하될 수 있음 
        
    - `트랜잭션` 항상 서브타입 개별로 처리 + `테이블` 하나로 통합하여 변환
        
        ⇒ 불필요하게 많은 양의 데이터가 집접되어 있어 성능이 저하될 수 있음 
        
    - `트랜잭션` 항상 Super type과 Sub type을 함께 처리하는데 개별로 유지
        
        ⇒ 조인에 의해 성능이 저하됨
        

## PK/FK

### **인덱스 특성을 고려한 PK/FK 칼럼 순서**

![https://k.kakaocdn.net/dn/IW1R0/btqOCcLivH0/5PgBoS8kjRkOe0yS415MiK/img.jpg](https://k.kakaocdn.net/dn/IW1R0/btqOCcLivH0/5PgBoS8kjRkOe0yS415MiK/img.jpg)

- PK/FK설계 시, `설계단계 마지막`에 칼럼의 순서를 조정
- PK순서는 실전 프로젝트에서 매우 중요
    - 가장 빈번하게 사용되는 유일한 인덱스(Unique Index)를 모두 자동 생성
    - 인덱스 정렬구조를 이해한 상태에서 PK순서를 지정
    - 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때, **앞쪽에 위치한 속성 값**
        - EQUAL 조건 : **`=`**
        - 범위조건 : **`BETWEEN`, `< >`**
- FK는 데이터 조회시 조인의 경로를 제공하는 역할 수행
    - FK는 **반드시 인덱스 설정**
    - FK는 조회의 조건을 고려하여 **접근이 가장 효율적인 칼럼 순서대로 인덱스를 생성**

# 5️⃣ 분산 데이터베이스 데이터에 따른 성능

### 분산 데이터베이스 정의

- 물리적으로 떨어진 데이터베이스를 네트워크로 연결해 단일 데이터베이스 이미지를 보여주고 분산된 작업 처리를 수행하는 데이터베이스
- 고객은 시스템이 네트워크로 분산되어 있는지 여부 인식 못함
- 하나의 결과가 여러 개의 시스템에 분산되어 저장
- 데이터 조회 성능을 위해 공통된 속성을 하나의 테이블로 묶을 수 있음

### 분산 데이터베이스 장단점

- 장점
    - 데이터베이스 신뢰성과 가용성이 높음
    - 병렬 처리 수행 → 빠른 응답 가능
- 단점
    - 관리와 통제가 어려움
    - 보안 관리 어려움
    - 데이터 무결성 관리가 어려움
    - 데이터베이스 설계 복잡 → 데이터 처리 비용 증가

### 분산 데이터베이스 활용

- 공통코드, 기준정보 등 마스터 데이터는 `복제분산`을 적용
- `거의 실시간(Near Real Time)` 업무적인 특정을 가질 때 사용
- 백업 사이트를 구성할때 `분산기능`을 적용하여 구성

⚠️  `GSI[Global Single Instance]`는 통합된 한 개의 인스턴스, 즉 통합 데이터베이스 구조를 의미 → **분산데이터베이스와 대치되는 개념**
