![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/942a0818-ad63-4d31-9337-26f64d3338c3/Untitled.png)

- SQL의 실행계획을 수립하고 SQL을 실행하는 DBMS 소프트웨어
- 사용자가 질의한 SQL 문에 대해 최적의 실행 방법을 결정하는 역할
    - 옵티마이저 실행 계획 → SQL 성능에 중요한 역할
- 최적의 실행 방법을 결정하는 방식
    - 규칙기반 옵티마이저
    - 비용기반 옵티마이저

### 1️⃣ 규칙 기반 옵티마이저 RBO(Rule Based Optimizer)

- 규칙(우선순위)를 가지고 실행계획을 생성하는 옵티마이저
- 실행계획을 생성하는 규칙을 이해하면 누구나 실행계획을 비교적 쉽게 예측 가능
- 규칙에 따라 우선순위를 정한 뒤 이를 기반으로 실행계획을 생성
- 제일 높은 우선순위는 행에 대한 고유 주소를 사용하는 방법
- 제일 낮은 우선순위는 전체 테이블 스캔하는 방법

### 2️⃣ 비용 기반 옵티마이저 CBO(Cost Based Optimizer)

- 테이블, 인덱스 등의 통계 정보를 활용해 가장 효율적인 SQL문 실행계획을 선택하는 옵티마이저
- 다양한 객체 통계정보와 시스템 통계정보 이용
- SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택
    
    → "비용"이란 SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량을 의미
    
- 현재 대부분의 관계형 데이터베이스에서는 비용기반 옵티마이저만 제공

### 3️⃣ 실행계획 Execution Plan

- SQL 처리를 위한 **실행 절차**와 **방법**을 표현한 것
- SQL을 어떤 순서로 어떻게 실행할 지를 결정하는 작업
    
    → 실행계획이 달라도 **실행 결과가 달라지는 것이 아니다**
    
- 실제 처리 건수 정보는 알 수 없다
- `액세스 기법`, `질의 처리 예상 비용`, `조인 순서`, `조인방법`는 알 수 있다
- **실행 계획의 실행순서는 위에서 아래로, 안에서 밖으로 읽는다.**
    - ex.>실행 계획의 실행순서 예
        
        ```sql
        1. NESTED LOOPS
        2.     HASH JOIN
        3.        TABLE ACCESS (FULL) TAB1
        4.        TABLE ACCESS (FULL) TAB2
        5.     TABLE ACCESS (BY ROWID) TAB3
        6.        INDEX (UNIQUE SCAN) PK_TAB3
        ```
        
        - "3→4→2→6→5→1" 실행순서를 가짐

### 실행계획에 나타나는 JOIN 기법

- Nested Loop Join
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1b34fef3-b886-4acf-9279-5ca83ea08e4d/Untitled.png)
    
    - OLTP 목록 처리 업무에 많이 사용됨
    - 조인 칼럼에 적당한 인덱스가 있어서 자연조인 Natural join이 효율적일 때 유용
    - Driving Table 조인 데이터 양이 큰 영향을 주는 조인 방식
    - 유니크 인덱스를 활용하여 수행시간이 **적게 걸리는 소량 테이블**을 온라인 조회하는 경우 효과적
    - 선택도가 낮은 (결과 행의 수가 적은) 테이블이 선행 테이블로 선택되는 것이 일반적으로 유리
    - 랜덤 액세스 방식으로 데이터를 읽음

- Hash Join
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18847ee1-0ee7-4109-a168-51c88ae09eac/Untitled.png)
    
    - DW 등의 데이터 집계 업무에 많이 사용됨
    - `Sort Merge Join` 하기엔 두 테이블이 너무 커서 sort 부하가 심할 때 유용
    - 한 쪽 테이블이 주 메모리의 메모리에 담길 정도로 충분히 작고 해시 키 속성에 **중복 값이 적을 때** 효과적
    - `Join` 컬럼에 적당한 인덱스가 없어서 `Natural Join`이 비 효율적일 때 효과적
    - 자연조인 시 `driving` 집합 쪽으로 조인 액세스량이 많아 `random` 액세스 부하가 심할 때 효과적
    - **행의 수가 작은 테이블**을 선행 테이블로 선택하는 것이 유리
    - 일반적으로 Sort Merge Join 보다 우수한 성능
    - Join 대상 테이블이 Join Key 컬럼으로 정렬되어 있을 때는 Sort Join이 더 우수한 성능을 낼 수도 있음
    - `EQUI JOIN` ‘`=`’ 조인만 가능

- Sort Merge Join
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7101592c-0a2b-46f9-bd36-b84f159aeab8/Untitled.png)
    
    - DW 등의 데이터 집계 업무에 많이 사용됨
    - full table scan 방식으로 데이터를 읽는 기법
    - 조인 칼럼을 기준으로 데이터를 정렬한 후 조인을 수행
    - `NOT EQUI JOIN` 에서도 사용 가능
        - cf> Hash JOIN은 불가능!

(A와 B를 조인할때는 NL 조인으로, B와 C를 조인할때는 HASH 조인으로 처리 가능)

| 구분 | Nested Loop Join | Sort Merge Join | Hash Join |
| --- | --- | --- | --- |
| 조인 방법 | 선행 테이블의 결과를 추출하고 후행 테이블을 읽으면서 조인을 수행한다. (중첩된 반복문과 유사)선행 테이블의 조건을 만족하는 행 수만큼 반복됨.조인이 성공하면 바로 결과를 보여줄 수 있다. | 조인 칼럼을 기준으로 테이블을 정렬하여 조인을 수행한다.조인할 테이블이 이미 정렬되어있다면 정렬 작업은 발생하지 않을수도 있다. | 조인 칼럼을 기준으로 해쉬함수를 수행하여 서로 동일한 해쉬값을 갖는 것들 사이에서 실제 값이 같은지를 비교하며 조인을 수행한다.NL join의 랜덤액세스 문제점과 Sort Merge Join의 정렬작업 부담 해결의 대안으로 등장했다.CPU연산을 많이하여 충분한 메모리 공간 필요하다. |
| 조인 제한 |  | 동등조인, 비동등조인에서 사용가능 | 동등조인에서만 사용할 수 있다. |
| 데이터 읽는방법 | 랜덤 액세스 방식 | 스캔 방식 |  |
| 처리범위 | 좁은 범위가 유리하다. | NL 조인에서 부담되던 넒은 범위의 데이터를 처리할 때 이용된다. (그러나 정렬이 많아지면 성능이 떨어질 수 있다) | 정렬작업이 없어 정렬이 부담되는 대량 배치작업에 유리하다. |
| 동작방법 | - 선행 테이블에서 주어진 조건을 만족하는 행을 찾음- 선행 테이블의 조인 키 값을 가지고 후행 테이블에서 조인 수행- 선행 테이블의 조건을 만족하는 모든 행에 대해 1번 작업 반복 수행 | - 선행 테이블 조인 키를 기준으로 정렬 작업을 수행- 후행 테이블 조인 키를 기준으로 정렬 작업을 수행- 정렬된 결과를 이용하여 조인을 수행하며 조인에 성공하면 추출버퍼에 넣음 | - 선행 테이블에서 조인 키를 기준으로 해쉬 함수를 적용하여 해쉬 테이블을 생성- 후행 테이블에서 조인 키를 기준으로 해쉬 함수를 적용하여 해당 버킷을 찾음- 조인에 성공하면 추출버퍼에 넣음- 후행 테이블의 조건을 만족하는 모든 행에 대해서 반복 수행 |

⚠️ 보통 대량의 조인 작업에서 정렬작업을 필요로 하는 `sort merge join` 보다는 `hash join` 이 성능상 유리

⚠️ **OLTP(온라인 트랜잭션 처리)**는 온라인 뱅킹, 쇼핑, 주문 입력 또는 텍스트 메시지 전송 등 동시에 발생하는 다수의 트랜잭션을 실행하는 데이터 처리 유형입니다.

⚠️ 세미 조인은 보통 EXISTS를 사용하는 서브쿼리의 형태로 나타나며 이러한 경우 서브 쿼리에 인덱스가 존재하지 않는다면 상당히 비효율적인데 이러한 서브 쿼리에 인덱스가 없는 경우 SEMI-JOIN이 일어나도록 유도한다면 성능의 향상을 꽤 할 수 있다. 즉 인덱스 없이 EXISTS를 사용하는 쿼리라면 HASH_SJ or MERGE_SJ or NL_SJ 힌트를 이용해서 세미조인이 일어나도록 푸는 것이 좋다.

NL, HASH, SORT Merge에 모두 나타날 수 있음

### SQL 처리 흐름도 (Access Flow Diagram)

- SQL 실행 시간은 알 수 없음
- 인덱스 스캔, 테이블 전체 스캔 등과 같은 액세스 기법이 표현
    - 인덱스 범위 스캔은은 결과 건수만큼 반환 →결과가 없으면 한 건도 반환하지 않을 수 있음
- 실행계획을 시각화 → SQL의 내부적인 처리 절차를 시각적으로 표현
- 성능적인 측면의 표현을 고려 및 표현 가능

### 옵티마이저와 실행계획

- ORACLE의 규칙기반 옵티마이저에서 가장 우선 순위가 높은 규칙
    - Single row by rowid 엑세스 기법
- 비용기반 옵티바이저는 테이블, 인덱스, 컬럼 등 객체의 통계저오를 사용하여 실행계획을 수립하므로 통계정보가 변경되면 SQL의 실행계획이 달라질 수 있음
- ORACLE의 실행계획에 나타나는 기본적인 Join 기법으로는 NL Join, Hash Join, Sort
