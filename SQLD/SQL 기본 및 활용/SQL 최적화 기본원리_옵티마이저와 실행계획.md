# 1️⃣ 옵티마이저와 실행계획

---

![image](https://user-images.githubusercontent.com/80308473/199528099-f77c3acc-70f0-4ffe-8fe7-c455e6109c07.png)

- SQL의 실행계획을 수립하고 SQL을 실행하는 DBMS 소프트웨어
- 사용자가 질의한 SQL 문에 대해 최적의 실행 방법을 결정하는 역할
    - 옵티마이저 실행 계획 → SQL 성능에 중요한 역할
- 최적의 실행 방법을 결정하는 방식
    - 규칙기반 옵티마이저
    - 비용기반 옵티마이저

### 1️⃣ 규칙 기반 옵티마이저

- 규칙(우선순위)를 가지고 실행계획을 생성하는 옵티마이저
- 실행계획을 생성하는 규칙을 이해하면 누구나 실행계획을 비교적 쉽게 예측 가능
- 규칙에 따라 우선순위를 정한 뒤 이를 기반으로 실행계획을 생성
- 제일 높은 우선순위는 행에 대한 고유 주소를 사용하는 방법
- 제일 낮은 우선순위는 전체 테이블 스캔하는 방법

### 2️⃣ 비용 기반 옵티마이저 CBO(Cost Based Optimizer)

- 테이블, 인덱스 등의 통계 정보를 활용해 가장 효율적인 SQL문 실행계획을 선택하는 옵티마이저
- 몇 개의 규칙만으로 현실의 모든 사항을 정확히 예측할 수 없다는 규칙기반 옵티마이저의 단점을 극복
- SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택 → "비용"이란 SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량을 의미
- 현재 대부분의 관계형 데이터베이스에서는 비용기반 옵티마이저만 제공

### 3️⃣ 실행계획 Execution Plan

- SQL 처리를 위한 **실행 절차**와 **방법**을 표현한 것
- SQL을 어떤 순서로 어떻게 실행할 지를 결정하는 작업
    
    → 실행계획이 달라도 **실행 결과가 달라지는 것이 아니다**
    
- 실제 처리 건수 정보는 알 수 없다
- `액세스 기법`, `질의 처리 예상 비용`, `조인 순서`, `조인방법`는 알 수 있다
- **실행 계획의 실행순서는 위에서 아래로, 안에서 밖으로 읽는다.**
    - ex.>실행 계획의 실행순서 예
        
        ```sql
        1. NESTED LOOPS
        2.     HASH JOIN
        3.        TABLE ACCESS (FULL) TAB1
        4.        TABLE ACCESS (FULL) TAB2
        5.     TABLE ACCESS (BY ROWID) TAB3
        6.        INDEX (UNIQUE SCAN) PK_TAB3
        ```
        
        - "3→4→2→6→5→1" 실행순서를 가짐

- 실행계획에 나타나는 JOIN 기법
    - Nested Loop Join
        - OLTP 목록 처리 업무에 많이 사용됨
        - 조인 칼럼에 적당한 인덱스가 있어서 자연조인 Natural join이 효율적일 때 유용
        - Driving Table 조인 데이터 양이 큰 영향을 주는 조인 방식
        - 유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 온라인 조회하는 경우 효과적
        - 선택도가 낮은 (결과 행의 수가 적은) 테이블이 선행 테이블로 선택되는 것이 일반적으로 유리
    - Hash Join
        - DW 등의 데이터 집계 업무에 많이 사용됨
        - `Sort Merge Join` 하기엔 두 테이블이 너무 커서 sort 부하가 심할 때 유용
        - 한 쪽 테이블이 주 메모리의 가용 메모리에 담길 정도로 충분히 작고 해시 키 속성에 중복 값이 적을 때 효과적
        - `Join` 컬럼에 적당한 인덱스가 없어서 `Natural Join`이 비효율적일 때 효과적
        - 자연조인 시 `driving` 집합 쪽으로 조인 액세스량이 많아 `random` 액세스 부하가 심할 때 효과적
        - 행의 수가 작은 테이블을 선행 테이블로 선택하는 것이 유리
        - 일반적으로 Sort Merge Join 보다 우수한 성능
            - Join 대상 테이블이 Join Key 컬럼으로 정렬되어 있을 때는 Sort Join이 더 우수한 성능을 낼 수도 있음
    - Sort Merge Join
        - DW 등의 데이터 집계 업무에 많이 사용됨
        - NOT EQUI JOIN 에서도 사용 가능

⚠️ OLTP(온라인 트랜잭션 처리)는 온라인 뱅킹, 쇼핑, 주문 입력 또는 텍스트 메시지 전송 등 동시에 발생하는 다수의 트랜잭션을 실행하는 데이터 처리 유형입니다.

⚠️ 세미 조인은 보통 EXISTS를 사용하는 서브쿼리의 형태로 나타나며 이러한 경우 서브 쿼리에 인덱스가 존재하지 않는다면 상당히 비효율적인데 이러한 서브 쿼리에 인덱스가 없는 경우 SEMI-JOIN이 일어나도록 유도한다면 성능의 향상을 꽤 할 수 있다. 즉 인덱스 없이 EXISTS를 사용하는 쿼리라면 HASH_SJ or MERGE_SJ or NL_SJ 힌트를 이용해서 세미조인이 일어나도록 푸는 것이 좋다.

NL, HASH, SORT Merge에 모두 나타날 수 있음

### SQL 처리 흐름도 (Access Flow Diagram)

- SQL 실행 시간은 알 수 없음
- 인덱스 스캔, 테이블 전체 스캔 등과 같은 액세스 기법이 표현
    - 인덱스 범위 스캔은은 결과 건수만큼 반환 →결과가 없으면 한 건도 반환하지 않을 수 있음
- 실행계획을 시각화 → SQL의 내부적인 처리 절차를 시각적으로 표현
- 성능적인 측면의 표현을 고려 및 표현 가능

### 옵티마이저와 실행계획

- ORACLE의 규칙기반 옵티마이저에서 가장 우선 순위가 높은 규칙
    - Single row by rowid 엑세스 기법
- 비용기반 옵티바이저는 테이블, 인덱스, 컬럼 등 객체의 통계저오를 사용하여 실행계획을 수립하므로 통계정보가 변경되면 SQL의 실행계획이 달라질 수 있음
- ORACLE의 실행계획에 나타나는 기본적인 Join 기법으로는 NL Join, Hash Join, Sort
