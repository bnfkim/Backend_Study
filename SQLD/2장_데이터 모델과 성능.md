### 성능 데이터모델링
- 데이터의 증가가 빠를수록 성능저하에 따른 성능 개선비용은 증가한다.
- 데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다.
- 분석, 설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능저하에 따른 rework비용을 최소화 할 수 있는 기회를 가지게 된다
- 분석/설계 단계에서 데이터베이스 처리 성능을 향상 시킬 수 있는 방법을 주도 면밀하게 고려해야 한다.
- 프로젝트 초기에 운영환경에 대비한 테스트 환경을 구현하고 그곳에 트랜잭션을 발생시켜 실제 성능을 테스트해 봐야한다.


### 성능 데이터 모델링 수행 절차
1. 데이터모델링을 할 떄 **정규화**를 정확하게 수행
2. 데이터베이스 **용량산정** 수행
3. 데이터베이스에 발생되는 **트랜잭션의 유형** 파악
4. 용량과 트랜잭션의 유형에 따라 **반정규화** 수행
5. **이력모델, PK.FK, 슈퍼타입/서브타입 조정** 등을 수행
6. 성능관점에서 **데이터모델을 검증**

### 성능데이터 모델링 고려사항
- **용량산정**은 전체적인 데이터베이스에 발생되는 **트랜잭션의 유형과 양을 분석**하는 자료가 되므로 성능데이터 모델링을 할 때 중요한 작업이 될 수 있다.
- 물리적인 데이터 모델링을 할 때 PK/FK의 칼럼의 순서조정, FK 인덱스 생성 등은 성능 향상을 위한 데이터 모델링 작업에 중요한 요소가 된다.
- 이력데이터는 시간에 따라 반복적으로 발생되기 때문에 대량 데이터일 가능성이 높아 특별히 성능을 고려하여 칼럼 등을 추가하도록 설계해야 한다.
- 데이터 모델링의 정규화는 중복된 데이터를 제거함으로써 조회성능을 향상시킬 수 있다.

### 정규화
- 1차 정규화
  - 칼럼에 의한 반복적인 속성값을 갖는 형태 제거
  - 중복된 데이터 제거
  - 1:M 관계로 두 개의 엔티티로 분리
- 2차 정규화
- 함수종속성의 규칙에 따라 PK인 엔티티가 2차 정규화로 분리
- PK 함수종속성 제거
- 주식별자 중 일부로부터 독립했기 때문에 1:M 관계로 연결된다

### 동일한 유형의 속성이 칼럼단위로 반복되는 경우
- 속성의 원자성을 위배한 제 1차 정규화의 대상이 된다.
- 어느 하나의 속성이라도 인덱스가 정의되어 있지 않을 경우
  -> 'or'로 연결된 모든 조건들이 인덱스를 사용하지 않고 한 번의 전체 데이터 스캔으로 처리가 되어 성능 저하가 나타난다.
- 모든 반복 속성에 인덱스를 생성하게 되는 경우
  -> 검색 속도는 좋아지겠지만, 너무 많은 인덱스로 입력+수정+삭제의 성능이 저하됨
 
### 반정규화를 고려할 때 판단요소
 - 반정규화 정보에 대한 재현의 적시성으로 판단한다.
  - ex. 빌링의 잔액은 다수 테이블에 대한 다량의 조인이 불가피하므로 데이터 제공의 적시성 확보를 위한 필수 반정규화 대상 정보이다.
 - 다량의 데이터 탐색의 경우, 인덱스가 아닌 다양한 물리 저장 기법을 활용하여 성능 개선을 유도한다.
  - ex. 파티션 및 데이터 클러스팅. *단 반복적인 과정이 빈번하게 나타날시 반정규화 고려하는 것이 좋다.
 - 이전 또는 이후 위치의 레코드에 대한 탐색은 window function으로 접근이 가능하다.
 - 집계 테이블 이외에서 다양한 유형에 대하여 반정규화 테이블 적용이 필요할 수 있다.
  - ex. 다수 테이블의 키 연결 테이블 등
  
### 반정규화 기법
- 테이블, 속성, 관계에 대해서 반정규화를 적용할 수 있다.
- 테이블추가 반정규화 기법 중 부분테이블 추가
- 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때, 디스크 I/O를 줄이기 위해 해당 칼럼들을 별도로 모아 놓는 정규화 기법

### 한 테이블에 많은 칼럼들이 존재할 경우
- 물리적으로 저장되는 디스크 상에 넓게 분포할 가능성이 커져 디스크 I/O가 대량으로 발생할 가능성이 높다.
- 트랜잭션이 접근하는 칼럼 유형을 분석하여 자주 접근하는 칼럼들과 상대적으로 접근 빈도가 낮은 칼럼들을 구분하여 1:1로 테이블을 분리해준다.
- 자주 사용되는 칼럼들 + 현시점에서 주로 사용되는 칼럼들을 모으고, 사용빈도가 낮은 칼럼 + 미래 시점에 사용될 것으로 예상되는 칼럼들을 한데 모아 별도의 1:1 관계 엔티티로 분리한다.
- 단순히 칼럼을 앞쪽과 뒤쪽으로 나눠 위치시키는 것은 더 많은 로우체인을 발생시킬 수 있다.

### 개별 테이블을 모두 조회하는 트랜잭션이 대부분일 경우
- UNION/UNION ALL 할 경우 개별조호에 따른 시간소요와 이것을 조합하는 성능저하가 발생.
- 하나의 테이블로 통합하도록 하고, 대신 PK체계나 일반속성에 각 사건을 구분할 수 있도록 구분자 부여

### 파티셔닝 (Partitioning)
- 하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇 개로 쪼개도 성능이 저하되는 경우에 사용
- 논리적으로는 하나의 테이블이지만, 물리적으로는 여러 개의 테이블로 분리하는 방법
- 데이터 액세스 성능도 향상시키고, 데이터 관리방법도 개선할 수 있도록 테이블에 적용하는 기법

### 논리테이블모델의 슈퍼타입과 서브타입 데이터모델을 물리적인 테이블 형식으로 변환하는 경우
- 트랜잭션은 항상 전체를 대상으로 일괄처리하는데, 테이블은 서브타입 별로 개별 유지하는 것으로 변환하면, Union 연산에 의해 성능이 저하될 수 있다.
- 트랜잭션은 항상 서브타입 개별로 처리하는데, 테이블은 하나로 통합하여 변환하면, 불필요하게 많은 양의 데이터가 집적되어 있어 성능이 저하될 수 있다.
- 트랜잭션은 항상 슈퍼+서브 타입을 함께 처리하는데, 개별로 유지 하면 조인에 의해 성능이 저하될 수 있다.
- 트랜잭션은 항상 전체를 통합하여 분석처리하는데, 슈퍼-서브타입이 하나의 테이블로 통합되어 있으면 다른 형식에 비해 더 성능이 우수하다
  - 하나의 테이블에 집적된 데이터만 읽어 처리할 수 있기 때문 

### 인덱스 액세스 범위를 좁히는 가장 좋은 방법
- 인덱스는 값의 범위에 따라 일정하게 정렬이 되어 있으므로 
- 상수값으로 EQUAL(=) 조건으로 조회되는 칼럼이 가장 앞으로 나오는 것이 좋다.
- 그리고 범위조회 하는 유형의 칼럼이 그 다음에 오도록하는 것이 인덱스 액세스 범위를 좁힐 수 있는 가장 좋은 방법이다.

### 데이터모델에 표현된 FK
- 엔티티 간에 논리적 관계가 있을 경우, 상호간에 조인이 자주 발생한다는 것을 의미하기 때문에 FK 제약조건 생성 여부와 상관없이 인덱스를 생성해주는 것이 좋다
- FK Constraints 는 인스턴스 간에 일관성을 보장하기 위해서 설계된 제약조건을 구현할 수 있도록 하나의 '지원 기능' 이다

### GSI (Global Single Instance)
- 통합된 한 개의 인스턴스
- 통합 데이터베이스 구조
- 분산데이터베이스와 대치되는 개념
